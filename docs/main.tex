% !TEX program = xelatex
\documentclass[a4paper, 12pt]{report}

\usepackage{fontspec}
\usepackage[romanian]{babel}
\usepackage{graphicx}
\usepackage{polyglossia}

\setdefaultlanguage{romanian}
\setotherlanguages{english}
\SetLanguageKeys{romanian}{indentfirst=true}

\usepackage[backend=biber]{biblatex}
\DeclareLanguageMapping{romanian}{romanian}
\addbibresource{bibliography.bib}

\usepackage{setspace}
\onehalfspace

\usepackage{hyperref}
\usepackage{csquotes}
\DeclareQuoteStyle{romanian}
  {\quotedblbase}
  {\textquotedblright}
  {\guillemotleft}
  {\guillemotright}

\usepackage{listings, listings-rust}
\usepackage{indentfirst}

\lstset{
    inputencoding=utf8,
    extendedchars=true,
    literate=
        {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
        {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
        {ă}{{\textnormal{ă}}}1
}

\lstdefinelanguage{rust}{
    inputencoding=utf8,
    extendedchars=true,
    literate=
        {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
        {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
}

\newenvironment{abstractpage}
  {\cleardoublepage\vspace*{\fill}\thispagestyle{empty}}
  {\vfill\cleardoublepage}
\renewenvironment{abstract}[1]
  {\bigskip\selectlanguage{#1}
   \begin{center}\bfseries\abstractname\end{center}}
  {\par\bigskip}

\title{Metodă eficientă de a desena imagini vectoriale}
\author{Alexandru-Gabriel Ică}
\date{\today}
\makeatletter

\begin{document}

\begin{titlepage}
    \begin{figure}[!htb]
        \centering
        \begin{minipage}{0.19\textwidth}
            \includegraphics[width=\linewidth]{img/UB_Logo.png}
        \end{minipage}
        \begin{minipage}{0.57\textwidth}
            \large
            \vspace{0.2cm}
            \begin{center}
                \textbf{Universitatea din București}
            \end{center}
            \vspace{0.3cm}
            \begin{center}
                \textbf{
                    Facultatea de \\
                    Matematică și Informatică
                }
            \end{center}
        \end{minipage}
        \begin{minipage}{0.21\textwidth}
            \includegraphics[width=\linewidth]{img/FMI_Logo.png}
        \end{minipage}
    \end{figure}

    \begin{center}
        Specializarea Informatică
    \end{center}

    \vspace{0.5cm}

    \begin{center}
        {\Large Lucrare de licență}
    \end{center}

    \begin{center}
        {\huge \@title}
    \end{center}

    \vspace{2.8cm}

    \begin{center}
        \large Absolvent \\ \@author
    \end{center}

    \vspace{0.25cm}

    \begin{center}
        \large Coordonator științific \\ Conf. Stupariu-Mihai Sorin
    \end{center}

    \vspace{2cm}

    \begin{center}
        \Large București, Iunie 2022
    \end{center}
\end{titlepage}
\makeatother

\tableofcontents

\begin{abstractpage}

    \begin{abstract}{romanian}
        Grafica vectorială este utilă pentru a desena forme geometrice la orice rezoluție fără alterarea calității. Două aplicații des întâlnite
        ale graficii vectoriale sunt desenarea textului și desenarea a diverse imagini în interfețe grafice, cum ar fi iconițele atașate
        meniurilor.

        În această lucrare prezint o bibliotecă care implementează algoritmii necesari pentru a desena figuri geometrice la orice rezoluție,
        într-un limbaj care facilitează integrarea acesteia în proiecte deja existente.
    \end{abstract}

    \begin{abstract}{english}
        Vector graphics is used to draw geometric shapes at any resolution without altering the quality of the image. Two popular use cases
        for vector graphics are text rendering and rendering of various images in graphical user interfaces, such as icons attached to menus.

        In this thesis I present a library which implements the necessary algorithms for rendering geometric shapes at any resolution, in a
        language which facilitates the integration of the library in already existing projects.
    \end{abstract}

\end{abstractpage}

\chapter{Motivație}

Grafica vectorială \cite{vector_graphics_wikipedia} reprezintă un mod de a genera imagini
direct din elemente geometrice precum segmente de dreaptă sau curbe. Acest mod de a reprezenta
imaginile diferă de modul „standard”, adică grafica rasterizată, prin faptul că desenul imaginii
nu își pierde calitatea indiferent de rezoluția la care vrem să o afișăm. De asemenea, imaginile
pot fi stocate mai eficient din punct de vedere al spațiului deoarece nu trebuie să reținem pixeli
la rezoluții mari.

Grafica vectorială este folosită foarte des, una din principalele utilizări fiind desenarea textului
pe ecran. Se poate regăsi și în interfețe grafice (de exemplu iconițe sau butoane) sau pe site-uri
web (în format SVG \cite{svg_standard}).

În ciuda faptului că grafica vectorială este des întâlnită, opțiunile pe care le avem pentru a putea
integra pe aceasta în proiecte nu sunt chiar triviale, menționăm câteva din cele mai folosite biblioteci:
\begin{itemize}
    \item{Skia \cite{skia_library}: o bibliotecă puternică, cu multe funcționalități, dar care suferă
                de un proces de integrare destul de complex, aceasta depinzând de Bazel \cite{bazel_build_system},
                care, la rândul lui, depinde de Java \cite{java_programming_language}}
    \item{Cairo \cite{cairo_library}: din nou o bibliotecă cu multe funcționalități, dar care suferă de aceeași
                problemă legată de procesul de integrare, mai ales pe sistemele de operare care nu sunt tip UNIX \cite{unix}}
    \item{Bibliotecile care vin la pachet cu diverse sisteme de operare: acestea sunt avantajoase deoarece pot fi
                integrate ușor. Inconvenientul este că sunt diferențe destul de mari între implementări, diferențe și de
                performanță și de calitate, este destul de dificil să se obțină un rezultat identic pe platforme diferite}
\end{itemize}

\section{Problema abordată}

Scopul principal este crearea unei biblioteci de grafică vectorială care să fie eficientă, ușor de integrat într-un proiect,
care să fie de o calitate înaltă și care să aibă aceeași calitate pe platforme diferite.
Pentru realizarea acestui fapt am ales să folosesc limbajul Rust \cite{rust_lang}. Motivul principal este că Rust are un manager
de pachete standard, ușor de folosit. Alt motiv este faptul că Rust este printre singurele limbaje populare care să
dispună de un astfel de manager de pachete, și care să concureze în aceeași nișă ca limbajele în care sunt implementate
bibliotecile menționate mai sus (C++ și C). Acest manager de pachete face integrarea într-un proiect mult mai ușoară.

\section{Obiective}

Obiectivul principal al acestei lucrări este o bibliotecă de grafică vectorială simplă, eficientă, ușor de folosit
și de integrat într-un proiect, cu funcționalități standard, care să aibă rezultate identice
pe orice platformă suportată.

\section{Proiecte din care m-am inspirat și propriile contribuții}

Pe lângă bibliotecile menționate mai sus, există și alte proiecte relevante care au un scop similar
cu acestea.

Anti-Grain Geometry \cite{antigrain_library} este o bibliotecă cu un algoritm de desenare de foarte mare calitate, descris
conceptual în documentația CL-VECTORS \cite{cl-aa_algorithm}. Algoritmul desenează segmente de dreaptă pe o grilă care împarte pixelii
în subpixeli, având astfel un efect de anti-aliere de calitate cât mai înaltă (în implementarea oficială anti-alierea este
de 256x). Inițial proiectul prezentat folosea acest algoritm, dar încercarea de a dezvolta
un algoritm eficient pentru a calcula intersecțiile segmentelor cu grila s-a dovedit a fi una mult prea dificilă.

Biblioteca \texttt{font-rs} \cite{font-rs_library} prezintă un algoritm eficient de desenare prezentat de Raph Levien
\cite{fastest_font_renderer_in_the_world}. Aceasta este biblioteca din care algoritmul de desenare din implementare se inspiră.
Algoritmul prezentat de Raph Levien se ocupă strict de desenarea fonturilor TrueType \cite{TrueType}, care
folosesc doar curbe Bézier \cite{bezier_curve} de gradul 2. Contribuțiile mele pentru această metodă sunt:

\begin{itemize}
    \item{Schimbarea algoritmului de convertire a curbelor Bézier de gradul 2 la reuniune de segmente de dreaptă (algoritm care va fi descris mai jos).}
    \item{Adăugarea suportului pentru a desena curbe Bézier de gradul 3.}
    \item{Implementarea operatorilor Porter-Duff \cite{Porter-Duff}.}
    \item{Adăugarea suportului pentru gradienți liniari, radiali și conici.}
\end{itemize}

Există și proiecte care au ca scop desenarea elementelor de grafică vectorială folosindu-se direct de placa video, pentru
eficiență sporită. Câteva exemple ar fi:

\begin{itemize}
    \item{„Signed Distance Fields” \cite{SDF_valve_paper} în care elementele de grafică vectorială sunt desenate inițial pe
                o textură inițială în care se salvează distanța până la cel mai apropiat segment.}
    \item{Metoda Loop-Blinn \cite{Loop-Blinn_algorithm} în care elementele de grafică vectorială sunt triangulate, iar apoi
                triunghiurile sunt trimise direct plăcii video.}
    \item{Slug \cite{Slug_library} în care se folosește algoritmul descris de Eric Lengyel \cite{Slug_paper}, care se folosește
                de un format intermediar pentru a stoca curbele Bézier într-o structură de accelerare, care sunt mai apoi verificate
                direct pe placa video în shaderul de fragment.}
    \item{MPVG \cite{MPVG_paper} în care elementele de grafică vectorială sunt stocate într-un arbore, iar curbele Bézier sunt
                împărțite în segmente monotone pentru care se implementează o variantă a algoritmului de umplere din Loop-Blinn.}
    \item{„Efficient GPU Path Rendering Using Scanline Rasterization” \cite{GPU_Scanline_paper} în care elementele de grafică
                vectorială sunt desenate într-o textură intermediară peste care se aplică algoritmul de sumă cumulativă.}
    \item{Pathfinder \cite{pathfinder_library} în care elementele de grafică vectorială sunt desenate pe o textură intermediară
                în care se calculează acoperirea fiecărui pixel, ca mai apoi shaderul de fragment să calculeze doar culorile necesare pentru
                fiecare pixel în funcție de acoperirea acestuia - o descriere mai detaliată a fost realizată de Nicolas Silva \cite{pathfinder_algorithm}.}
\end{itemize}

În principal problema folosirii plăcii video este aceea a portabilității. Unul din obiectivele implementării prezentat este ca biblioteca să
fie ușor de integrat pe orice platformă, pe când placa video restricționează semnificativ acest lucru. Multe din metodele
menționate mai sus folosesc funcționalități avansate ale plăcilor video, care pot lipsi în anumite cazuri. În plus, acestea
folosesc algoritmi destul de greu de implementat/testat, și metode precum Loop-Blinn sau Slug încă se folosesc foarte mult
de procesor pentru a prelucra elementele grafice. Mai mult, folosirea plăcii video limitează foarte mult posibilitatea extinderii
implementării cu funcționalități noi, deoarece placa video nu poate rula algoritmi normali fără modificări serioase, care uneori
pot aduce chiar regrese când vine vorba de performanță. Acestea sunt principalele motive pentru care proiectul prezentat folosește o
metodă clasică, care se folosește integral de procesor.

\chapter{Algoritmul de bază}

Pentru a desena figuri geometrice, implementarea se folosește de două dreptunghiuri. Primul dreptunghi este cel care reprezintă spațiul
în care sunt specificate coordonatele punctelor figurilor. Acesta începe la punctul \((0, 0)\) în colțul din stânga-sus, și se termină
la rezoluția specificată de utilizator. Al doilea dreptunghi este dreptunghiul care reprezintă rezoluția la care se va desena imaginea finală,
pe care îl numesc „dreptunghiul imaginii”.
Dimensiunile acestuia pot fi mai mari sau mai mici decât primul dreptunghi. Implementarea efectuează o asociere a punctelor primului dreptunghi
cu punctele din dreptunghiul imaginii. Această asociere permite desenarea figurilor la orice rezoluție, fără pierderea calității. Mai jos este
descris algoritmul care lucrează direct asupra dreptunghiului imaginii.

\section{Descrierea algoritmului la nivel înalt}

Implementarea este împărțită în 2 etape:

\begin{itemize}
    \item{Desenarea dreptelor}
    \item{Acumularea acoperirii pixelilor în urma desenării dreptelor, printr-o sumă cumulativă}
\end{itemize}

Se folosește o zonă de memorie dedicată stocării acoperirii pixelilor, care este denumită „buffer de acumulare”. Prin „desenarea dreptelor”
mă refer la calcularea acoperirii fiecărui pixel care face parte din segmentul de dreaptă, și stocarea acesteia în acel buffer de acumulare.
Pentru a calcula aceste acoperiri se folosește algoritmul lui Raph Levien din \texttt{font-rs} \cite{fastest_font_renderer_in_the_world}.
Această etapă reprezintă trecerea de la spațiul continuu, în care sunt descrise figurile, la spațiul discret, adică rezoluția imaginii.

În etapa a 2-a, se parcurge bufferul de acumulare și se calculează suma cumulativă a acoperirilor. Regula de umplere folosită este cea
„non-zero” \cite{non_zero_rule} din SVG, adică cea în care un segment care este orientat de la stânga la dreapta va contribui pozitiv la acoperire,
iar un segment orientat invers va contribui negativ la acoperire. Când acoperirea este diferită de 0 înseamnă că suntem în
interiorul unei figuri. Pentru a descrie figurile, se folosesc câteva structuri ajutătoare. Cea mai importantă dintre ele
este aceea care descrie operațiile care se pot efectua în cadrul unei figuri (similare cu cele din SVG), ilustrată în figura \ref{fig-enum-pathops}.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
pub enum PathOps {
    // f64: echivalent cu double din C
    // Fiecare operator are un echivalent în descrierea
    // figurilor din SVG.
    MoveTo { x: f64, y: f64 }, // echivalent cu: "M x y"
    LineTo { x: f64, y: f64 }, // echivalent cu: "L x y"
    QuadTo {
        x1: f64, y1: f64, x2: f64, y2: f64
    }, // echivalent cu: "Q x1 y1, x2 y2"
    CubicTo {
        x1: f64, y1: f64, x2: f64, y2: f64,
        x3: f64, y3: f64,
    }, // echivalent cu: "C x1 y1, x2 y2, x3 y3"
    Close, // echivalent cu: Z
}
    \end{lstlisting}
    \caption{Structura \texttt{PathOps}}
    \label{fig-enum-pathops}
\end{figure}

Inițial figura începe la coordonata \((0, 0)\). Fiecare din operațiile de mai sus descrie traseul figurii. De exemplu, pentru a desena
un triunghi într-un spațiu de \(100 \times 100\) pixeli se pot înșirui operațiile ilustrate în figura \ref{fig-descrierea-unui-triunghi}.
Operația \texttt{PathOps::Close} va trasa o dreaptă până la punctul din care a început figura - adică ultimul \texttt{MoveTo}. În cod,
pentru a apela funcția de desenare se poate utiliza funcția \texttt{draw\_shape}, după cum se poate vedea în figura \ref{fig-desenarea-unui-triunghi}.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
    let triangle = [
        PathOps::MoveTo { x: 50.0, y: 0.0 },
        PathOps::LineTo { x: 100.0, y: 100.0 },
        PathOps::LineTo { x: 0.0, y: 100.0 },
        PathOps::Close
    ];
    \end{lstlisting}
    \caption{Descrierea unui triunghi folosind \texttt{PathOps}}
    \label{fig-descrierea-unui-triunghi}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
    canvas.draw_shape(
        &triangle,
        FillStyle::Plain(Color::red()),
        FillRule::NonZero,
        |p| *p
    );
    \end{lstlisting}
    \caption{Desenarea unui triunghi}
    \label{fig-desenarea-unui-triunghi}
\end{figure}

Astfel se va desena un triunghi roșu, ilustrat în figura \ref{fig-triunghi-simplu}. Ultimul parametru poate fi ignorat momentan, acesta reprezintă o
transformare afină care se poate aplica punctelor din descrierea figurii. În acest exemplu nu am aplicat nicio transformare.
\texttt{Canvas} va fi descris mai jos. În bibliotecă mai sunt implementate și operațiile \texttt{MoveToRel, LineToRel, QuadToRel, CubicToRel},
care sunt echivalente cu operațiile de mai sus, doar că vor calcula următoarea poziție relativ la ultimul punct, spre deosebire de cele arătate
mai sus, în care sunt specificate coordonate absolute.

\begin{figure}[ht]
    \includegraphics[height=5cm]{triunghi_simplu.png}
    \centering
    \caption{Triunghiul rezultat din codul descris în figura \ref{fig-desenarea-unui-triunghi}}
    \label{fig-triunghi-simplu}
\end{figure}

\section{Detalii despre implementare}

Algoritmul care calculează acoperirea pixelilor care fac parte din segmentele de dreaptă funcționează prin parcurgerea dreptei, ținând cont
de cât de mult acoperă dreapta pixelul curent. În caz că nu este acoperit la maxim, se stochează acoperirea rămasă și pe
pixelul vecin. Astfel se ajunge și la eliminarea fenomenului de aliere.

În figura \ref{fig-linie-verticala} se poate vedea cum se calculează acoperirile pentru o dreaptă diagonală, desenată în sens
invers trigonometric. Inițial primul pixel este acoperit în întregime
de dreaptă și este colorat cu roșu opac, dar pe măsură ce dreapta progresează, pixelii de la început sunt acoperiți tot mai puțin
de dreaptă, astfel fiind colorați doar parțial cu roșu (se modifică parametrul care descrie opacitatea), într-un final ajungându-se la
acoperire 0. Dar indiferent de acoperirea pixelilor de la început, pe final se ajunge oricum la roșu opac, deoarece acoperirile pixelilor
sunt însumate, iar însumarea lor va rezulta mereu în acoperire maximă.

În figura \ref{fig-linie-oblica} se poate observa cum o dreaptă oblică va avea mereu acoperire de \(50\%\) la primii pixeli. Pixelii imediat
vecini vor avea o acoperire identică, astfel suma lor ajungând la acoperire maximă. Atunci când dreptele sunt specificate de la dreapta
la stânga valorile acoperirilor sunt identice, dar vor fi negative, pentru a păstra proprietatea că suma cumulativă trebuie să fie
0 atunci când suntem în afara unei figuri.

\begin{figure}[ht]
    \includegraphics[height=5cm]{linie_aproximativ_verticala.png}
    \centering
    \caption{Dreaptă aproape verticală}
    \label{fig-linie-verticala}
\end{figure}

\begin{figure}[ht]
    \includegraphics[height=5cm]{linie_oblica.png}
    \centering
    \caption{Dreaptă înclinată la 45 de grade}
    \label{fig-linie-oblica}
\end{figure}

\subsection{Cum tratez dreptele orizontale?}

Un caz particular al acestei metode este reprezentat de dreptele orizontale. Conceptual nu are sens ca o dreaptă
orizontală să aibă acoperiri ale pixelilor. Acest lucru nu ar face posibilă calcularea sumei cumulative în mod corect.
De exemplu, dacă fiecare pixel de pe o dreaptă orizontală ar avea acoperire \(100\%\), suma cumulativă ar deveni egală
cu numărul de pixeli. Această sumă este mult prea mare pentru a se putea ajunge înapoi la 0 pentru delimita figura.
Astfel, desenarea s-ar face în mod incorect.

Soluția este ignorarea dreptelor orizontale. O figură bine definită va avea mereu segmente care nu sunt orizontale,
acestea dictând suma cumulativă. În cazul triunghiului desenat în figura \ref{fig-triunghi-simplu}, baza are acoperirile
dictate de dreapta oblică din stânga. Biblioteca acceptă doar figuri bine definite, adică figuri închise, similar cum SVG
acceptă doar figuri închise pentru algoritmii de umplere.

\chapter{Extinderea algoritmului la mai multe primitive}

Pentru a facilita desenarea figurilor mai complexe, algoritmul de bază a fost extins adăugând suport pentru curbe Bézier
de gradul 2 și gradul 3. Ideea implementării este de a converti curbele la o reuniune de segmente de dreaptă suficient de „densă” pentru
a nu se putea observa faptul că de fapt am desenat mai multe segmente de dreaptă, și nu am lucrat analitic cu curbele.

\section{Curbe Bézier de gradul 2}

Curbele Bézier de gradul 2 sunt reprezentate sub forma unei combinații a polinoamelor Bernstein \cite{bernstein_polynomial}:

\[
    B(t) = (1 - t)^2 P_0 + 2 (1 - t) t P_1 + t^2 P_2, \ 0 \leq t \leq 1,
\] unde \(P_0, P_1, P_2\) sunt punctele de control ale curbei.

Pentru a converti curbele Bézier de gradul 2 la reuniunea de drepte, implementarea se folosește de metoda prezentată de Raph Levien
\cite{FlatteningQuadraticBezierCurves}. Metoda propusă prezintă o formulă pentru calcularea numărului de segmente
necesare pentru a reprezenta curba, folosindu-se de proprietatea curbelor Bézier de gradul 2 care ne spune că acestea
pot fi interpretate ca o secțiune dintr-o parabolă \(y = x^2\), modulo rotație, scalare și translație.

Distanța maximă între curbă și coardă pentru o parabolă \(y = x^2\) este aproximativ \(\frac{1}{8} \kappa \Delta s^2\),
unde \(\kappa\) reprezintă curbura iar \(\Delta s\) reprezintă o distanță tinzând spre 0, astfel considerând o coardă cât mai mică.
Formulele pentru acestea, pentru o parabolă, sunt relativ simple:

\[
    \kappa = \frac{f''(x)}{\left(1 + f'(x)^2\right)^{\frac{3}{2}}} = \frac{2}{\left(1 + 4x^2\right)^{\frac{3}{2}}}
\]
\[
    \Delta s = \sqrt{1 + \left(\frac{dy}{dx}\right)^2} dx = \sqrt{1 + 4x^2} \Delta x
\]

Înlocuind acestea în formula de mai sus putem determina pe \(\Delta x\):

\[ \Delta x = 2 \sqrt{\Delta y} \sqrt[4]{1 + 4 x^2} \], care reprezintă „pasul” necesar pentru fiecare dreaptă. Pentru a afla numărul de segmente vom calcula inversul aceste expresii,
luat pe intervalul pe care îl dorim:

\[
    f(x) = nr. segmente = \frac{1}{2 \sqrt{\Delta y}} \int\limits_{x_0}^{x_1} \frac{1}{\sqrt[4]{1 + 4x^2}} dx
\]

Pentru determinarea parametrului \(t\) pentru fiecare segment generat, este necesară calcularea inversului acestei funcții. Metoda
propusă oferă două aproximări pentru calcularea acestora:

\[
    f(x) \approx \frac{x}{0.33 + \sqrt[4]{0.67^4 + \frac{1}{4} x^2}}
\]
\[
    f^{-1}(x) \approx x \left( 0.61 + \sqrt{0.39^2 + \frac{1}{4} x^2} \right)
\]

În implementare se folosește o structură care să faciliteze lucrul cu curbele Bézier de gradul 2, așa cum este prezentată în
figura \ref{fig-struct-quadbezier}. Convertirea la segmente de dreaptă, prezentată în figura \ref{fig-quadbezier-subdivide}, se efectuează folosind
ideea prezentată mai sus. După cum se poate vedea, algoritmul nu este recursiv, spre deosebire de metoda De Casteljau \cite{DeCasteljau_algorithm}
care este folosită de obicei.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
// (x0, y0), (x1, y1) și (x2, y2) sunt punctele
// de control ale curbei de gradul doi
pub struct QuadraticBezier {
    x0: f64, y0: f64,
    x1: f64, y1: f64,
    x2: f64, y2: f64
}
    \end{lstlisting}
    \caption{Structura care descrie curbele Bézier de gradul 2}
    \label{fig-struct-quadbezier}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
pub fn subdivide(&self, err: f64) -> Vec<f64> {
    let params = self.map_to_basic();
    let (a0, a2) = (
        approximate_integral(params.x0),
        approximate_integral(params.x2)
    );
    let count = 0.5 * f64::abs(a2 - a0)
        * f64::sqrt(params.scale / err);
    let n = f64::ceil(count);
    let (u0, u2) = (
        approximate_inverse_integral(a0),
        approximate_inverse_integral(a2)
    );
    let mut result = vec![0_f64];

    for i in 1..(n as i32) {
        let u = approximate_inverse_integral(
            a0 + ((a2 - a0) * (i as f64)) / n
        );
        let t = (u - u0) / (u2 - u0);
        result.push(t);
    }

    result.push(1.0); return result;
}
    \end{lstlisting}
    \caption{Algoritmul de convertire a curbelor Bézier de gradul 2 la reuniune de segmente de dreaptă}
    \label{fig-quadbezier-subdivide}
\end{figure}

În figura \ref{fig-curba-bezier-de-ordin-2} se poate vedea un exemplu de curbă Bézier de gradul 2 desenată folosind metoda
prezentată mai sus, cu un parametru de toleranță de \(0.5\) - parametru care decide cât de „aproape” de curba ideală vrem
să fim; cu cât valoarea este mai mică cu atât curba va arăta mai „curbată”, dar se vor genera mult mai multe segmente și
performanța poate scădea. Poza este mărită intenționat pentru a observa calitatea implementării. Deși în figură se poate observa
faptul că doar am generat drepte în loc să desenez o curbă, în practică acest lucru este aproape invizibil, mai ales când
se desenează text. Curbele vor fi oricum de dimensiuni reduse sau nu vor avea astfel de curburi extreme. Este demonstrat acest fapt prin figura
\ref{fig-litera-arond}. A fost desenată cu un parametru de toleranță chiar mai mare, adică \(1.0\), și se poate observa cum
este invizibil faptul că s-au generat segmente de dreaptă pentru a desena curbele care constituie litera „@”.

\begin{figure}[ht]
    \includegraphics[height=5cm]{curba_bezier_de_ordin_2.png}
    \centering
    \caption{Figura delimitată de o curbă Bézier de gradul 2 și două segmente de dreaptă}
    \label{fig-curba-bezier-de-ordin-2}
\end{figure}

\begin{figure}[ht]
    \includegraphics[height=5cm]{litera_arond.png}
    \centering
    \caption{Litera „@” desenată folosind metoda menționată}
    \label{fig-litera-arond}
\end{figure}

\section{Curbe Bézier de gradul 3}

Pentru a converti curbele Bézier de gradul 3 la reuniune de segmente de dreaptă, implementarea folosește algoritmul de subdivizare al lui De Casteljau, mai exact metoda
prezentată de Kaspar Fischer \cite{DeCasteljau_algorithm}. O curbă Bézier de gradul 3 este reprezentată, de asemenea, sub forma unei combinații a
polinoamelor Bernstein \cite{bernstein_polynomial}:

\[
    B(t) = (1 - t)^3 P_0 + 3 (1 - t)^2 t P_1 + 3 (1 - t) t^2 P_2 + t^3 P_3, \ 0 \leq t \leq 1,
\] unde \(P_0, P_1, P_2, P_3\) sunt punctele de control ale curbei Bézier de gradul 3.

Algoritmul lui De Casteljau ne dă o metodă prin care să împărțim curba la un anumit \(t\) în 2 curbe mai mici,
de același grad. Metoda menționată propune un algoritm care decide când este necesară oprirea divizării curbei în două jumătăți,
adică stadiul în care se consideră că dreapta curentă este suficient de mică astfel încât efectul vizual să fie cât mai bun.
În figura \ref{fig-cubic-split} este prezintat codul care se ocupă cu această evaluare, care se folosește la rândul
ei de un parametru de toleranță.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
// is_sufficiently_flat
let mut u = 3.0 * p1 - 2.0 * p0 - p3;
let mut v = 3.0 * p2 - 2.0 * p3 - p0;

// u și v sunt doi factori care constituie lungimea
// cea mai mare între curba și dreapta care unesc
// punctele de control p0 și p3
let (mut ux, mut uy) = (u.x * u.x, u.y * u.y);
let (mut vx, mut vy) = (v.x * v.x, v.y * v.y);

ux = if u.x < v.x { v.x } else { ux };
uy = if u.y < v.y { v.y } else { uy };

// Întoarce valoarea 1 atunci când lungimea este
// în limitele parametrului tolerance (specificat),
// astfel algoritmul va opri procesul de subdivizare,
// altfel se întoarce 0 și subdivizarea va continua
let is_flat = ux + uy <= tolerance;
    \end{lstlisting}
    \caption{Instrucțiunile care decid când o dreaptă este suficient de mică pentru a ne opri în subdivizarea De Casteljau}
    \label{fig-cubic-split}
\end{figure}

Generarea setului de segmente de dreaptă este implementată printr-un algoritm recursiv, descris în figura \ref{fig-subdivision-algorithm}.
În figura \ref{fig-cubic-example} se poate vedea o demonstrație a metodei de desenare a curbelor Bézier de gradul 3.
Parametrul de toleranță folosit pentru generare a fost \texttt{0.25}. Din nou, faptul că s-au folosit segmente de dreaptă pentru a „simula”
curba este practic vizual invizibil.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
fn subdivide(&self, lines: &mut Vec<Point>, tolerance: f64) {
    if self.is_sufficiently_flat(tolerance) {
        lines.push(Point {
            x: self.x3,
            y: self.y3,
        });

        return;
    }
    let (left, right) = self.split();
    left.subdivide_impl(lines, tolerance);
    right.subdivide_impl(lines, tolerance);
}
    \end{lstlisting}
    \caption{Algoritmul care convertește curbe Bézier de gradul 3 la reuniune de segmente de dreaptă}
    \label{fig-subdivision-algorithm}
\end{figure}

\begin{figure}[ht]
    \includegraphics[height=5cm]{curba_cubica.png}
    \centering
    \caption{Figură determinată de mai multe curbe Bézier de gradul 3}
    \label{fig-cubic-example}
\end{figure}

\section{Desenare de text}

Având implementarea pentru primitivele mai sus menționate, se poate desena text prin desenarea de caractere descrise prin
fonturi precum TrueType \cite{TrueType}. Caracterele sunt descrise prin curbe Bézier, astfel fiind necesară doar traducerea
descrierii din formatul TrueType în formatul pe care îl acceptă implementarea. Pentru citirea formatului TrueType, opțiunea aleasă
a fost pachetul \texttt{ttf\_parser} \cite{TrueTypeParser}.

Acest pachet permite implementarea a cinci funcții care vor fi folosite pentru
traducerea descrierii caracterelor din formatul TrueType în formatul bibliotecii, așa cum este demonstrat în figura
\ref{fig-ttf-parser-demo}. Este ilustrată doar funcția \texttt{move\_to}, dar implementarea se adaptează ușor la celelalte funcții.
Există câte o funcție pentru fiecare primitivă din enumerarea \texttt{PathOps} prezentată mai sus. În figurile
\ref{fig-text-verg} și \ref{fig-text-fmi} se pot vedea două exemple de text desenat folosind implementarea descrisă anterior. Figura
\ref{fig-text-verg} a fost generată folosind fontul Roboto \cite{Roboto}, iar figura \ref{fig-text-fmi} a fost generată
folosind fontul Wildwood \cite{Wildwood}.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
fn move_to(x: f32, y: f32) {
    path_ops.push(PathOps::MoveTo {
        x: (x - min_x) as f64,
        y: height as f64 - (y - min_y) as f64,
    });
}
    \end{lstlisting}
    \caption{Funcția \texttt{move\_to} folosită de \texttt{ttf\_parser}}
    \label{fig-ttf-parser-demo}
\end{figure}

\begin{figure}[ht]
    \includegraphics[width=5cm]{text_verg.png}
    \centering
    \caption{Numele proiectului prezentat, desenat folosind chiar implementarea}
    \label{fig-text-verg}
\end{figure}

\begin{figure}[ht]
    \includegraphics[width=5cm]{text_fmi.png}
    \centering
    \caption{Textul „FMI” desenat folosind proiectul prezentat}
    \label{fig-text-fmi}
\end{figure}

\chapter{Efecte}

Pentru a permite descrierea figurilor mai complexe, am implementat în bibliotecă și suport pentru efectul de gradient.
Mai concret, am implementat suport pentru gradienți liniari, radiali și conici, care vor fi descriși în detaliu mai jos.
De asemenea, am introdus și suport pentru diverși operatori de amestecare, adică operatorii Porter-Duff \cite{Porter-Duff}.
Se pot introduce inclusiv funcții de amestecare care să fie definite de utilizator, pentru flexibilitate maximă. În plus,
am adăugat suport și pentru transformări afine asupra punctelor care constituie figurile.

\section{Gradienți}

Gradienții funcționează prin calcularea unui parametru \texttt{t} între \texttt{0} și \texttt{1} care dictează cât de mult
s-a parcurs gradientul la poziția \((x, y)\). În implementare, pentru o figură arbitrară, gradientul pornește prin a
determina dreptunghiul care acoperă în întregime figura. Apoi, în pasul în care se calculează suma cumulativă a acoperirilor,
acel \texttt{t} se va determina raportat la dreptunghiul calculat anterior. Mai jos sunt descrise câteva detalii importante din
implementare pentru fiecare tip de gradient, ilustrați în figura \ref{fig-gradients}. Implementările pentru gradienți sunt adaptate
după modelul prezentat în standardul SVG 1.1 \cite{SVG_Gradients}.

\begin{figure}[ht]
    \includegraphics[height=5cm]{gradienti.png}
    \centering
    \caption{Exemplu de gradienți (de sus în jos) liniari, radiali și conici}
    \label{fig-gradients}
\end{figure}

\subsection{Gradienți liniari}

În cazul gradienților liniari există câțiva parametri la care se raportează aceștia:

\begin{itemize}
    \item{\((x, y)\) - punctul din dreptunghiul care acoperă figura, în care se desenează gradientul}
    \item{\(((min\_x, min\_y), (max\_x, max\_y))\) - coordonatele dreptunghiului care acoperă figura}
    \item{\texttt{stops} - un șir de perechi \((Culoare, t)\), unde \texttt{t} reprezintă o valoare între \(0\) și \(1\)
                care semnifică culoarea care se va afla la acel parametru \texttt{t} din gradient}
\end{itemize}

Pentru efectul de gradient se interpolează liniar culorile din șirul \texttt{stops} în funcție de culorile între care se află
parametrul \texttt{t}. Pentru a calcula parametrul \texttt{t} se folosește implementarea din figura \ref{fig-linear-gradient-impl}.
Pentru a calcula culoarea finală din gradient, se va efectua interpolarea liniară ilustrată în figura \ref{fig-linear-gradient-interpolation}.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
let clamped_x = clamp(x, min_x, max_x);
let fx = (clamped_x - min_x) / gradient_width;
let mut stop_index = 0_usize;
while stop_index < stops.len() && stops[stop_index].1 < fx {
    stop_index += 1;
}
stop_index = clamp(stop_index, 0, stops.len() - 1);
let (mut c1, mut c2) = (stops[stop_index-1].0, stops[stop_index].0);
let (s1, s2) = (stops[stop_index - 1].1, stops[stop_index].1);
let t = (fx - s1) / (s2 - s1);
    \end{lstlisting}
    \caption{Calcularea parametrului \texttt{t} pentru gradienții liniari}
    \label{fig-linear-gradient-impl}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
Color {
    r: (1.0 - t) * c1.r + t * c2.r,
    // similar pentru g (green), b (blue) și a (alpha)
}
    \end{lstlisting}
    \caption{Interpolare liniară între culorile din \texttt{stops} ale gradientului liniar}
    \label{fig-linear-gradient-interpolation}
\end{figure}

\subsection{Gradienți radiali}

Gradienții radiali au aceiași parametri precum cei liniari. Singura diferență este modul în care se calculează acel parametru
\texttt{t}. De data aceasta parametrul este calculat în funcție de distanța în modul a punctului \((x, y)\) față de centrul
dreptunghiului care acoperă figura. Această distanță este calculată folosind codul din figura \ref{fig-radial-gradient-impl}.
În rest implementarea este identică cu cea de la gradienții liniari, făcându-se interpolare liniară între elementele din
\texttt{stops}.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
let gradient_width = max_x - min_x;
let dist = p.distance_to(&center).abs() / gradient_width;
    \end{lstlisting}
    \caption{Calcularea distanței față de centrul dreptunghiului care acoperă figura, pentru gradienții radiali}
    \label{fig-radial-gradient-impl}
\end{figure}

\subsection{Gradienți conici}

În cazul gradienților conici există, de asemenea, parametri identici cu celelalte tipuri de gradient. Modul de calculare al parametrului
\texttt{t} diferă din nou. De această dată parametrul \texttt{t} este interpretat ca fiind un procent din unghiul \(2\pi\).
Raportarea se efectuează tot la centrul dreptunghiului care acoperă figura. Pentru a calcula unghiul dintre punctul \((x, y)\) și centrul
dreptunghiului se folosește funcția \(atan2\), așa cum este ilustrat în figura \ref{fig-conic-gradient-impl}. Restul
implementării este identic cu celelalte implementări de gradienți.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Rust]
let angle = Angle::from_radians(
    f64::atan2(center.y - y, x - center.x)
.abs());
    \end{lstlisting}
    \caption{Calcularea în modul a unghiului dintre punctul \((x, y)\) și centrul dreptunghiului care acoperă figura, pentru gradienții conici}
    \label{fig-conic-gradient-impl}
\end{figure}

\section{Amestecare}

Pentru a facilita mai multe efecte în descrierea figurilor, în implementare există suport pentru diverși operatori de amestecare,
mai exact operatorii introduși de Porter-Duff \cite{Porter-Duff}. Procesul de amestecare are loc în etapa calculării sumei
cumulative a acoperirilor, acoperirea fiind chiar factorul de amestecare. Culoarea sursă (pe care o notez cu \(S\)) și culoarea
destinație (pe care o notez cu \(D\)) reprezintă parametrii necesari pentru amestecare. Operatorii de amestecare reprezintă
combinații liniare între aceste culori. Toți operatorii sunt ilustrați în figura \ref{fig-alpha-compositing}. Mai jos sunt descrise
combinațiile liniare pentru operatorii de amestecare. \(S_A\) și \(D_A\) reprezintă factorii de amestecare pentru culoarea sursă
și pentru culoarea destinație. În cazul culorii sursă factorul de amestecare este reprezentat chiar de acoperire, iar în cazul
culorii destinație, acesta este valoarea care este stocată la acel moment în bufferul de culori:

\begin{itemize}
    \item{\texttt{source-over}: sursa acoperă destinația.}
    \item{\texttt{destination-over}: destinația acoperă sursa.}
    \item{\texttt{source-out}: sursa este desenată în limitele destinației.}
    \item{\texttt{destination-out}: destinația este desenată în limitele sursei.}
    \item{\texttt{source-in}: sursa este desenată în afara limitelor destinației.}
    \item{\texttt{destination-in}: destinația este desenată în afara limitelor sursei.}
    \item{\texttt{source-atop}: nu se desenează intersecția dintre sursă și destinație.}
    \item{\texttt{destination-atop}: destinația este acoperită în limitele sursei.}
    \item{\texttt{xor}: se desenează intersecția dintre sursă și destinație.}
    \item{\texttt{source}: se desenează doar sursa.}
    \item{\texttt{destination}: se desenează doar destinația.}
    \item{\texttt{additive}: se adună opacitățile sursei și destinației.}
\end{itemize}

\begin{figure}[ht]
    \includegraphics[height=5cm]{amestecare.png}
    \centering
    \caption{Operatorii de amestecare, în ordine, de sus în jos, de la stânga la dreapta}
    \label{fig-alpha-compositing}
\end{figure}

\section{Transformări}

Pentru a ușura descrierea figurilor complexe, implementarea s-a extins prin adăugarea suportului pentru transformări afine asupra punctelor ce definesc
o figură. În implementare, transformările sunt specificate folosind funcții care au ca parametru un punct \((x, y)\) și
care returnează tot un punct. Fiecare transformare afină va avea anumiți parametri specifici în plus.
Mai exact, proiectul implementează suport pentru transformările:

\begin{itemize}
    \item{Translație - punctul \((x, y)\) se adună cu un decalaj \((tx, ty)\).}
    %\begin{itemize}
    %    \item \(transform(x, y, offset) = (x + offset.x, y + offset.y)\)
    %\end{itemize}
    \item{Rotație - punctul \((x, y)\) se rotește cu unghiul \(\alpha\) prin folosirea numerelor complexe \cite{affine_transform_rotation}, obținându-se \((x', y')\):
                \[x' + y' i = (x + y i) (\cos(\alpha) + i \sin(\alpha))\]}
    %\begin{itemize}
    %    \item \(transform(x, y, angle) = (\\
    %          \ \ \ x \times sin(angle) - y \times cos(angle),\\
    %          \ \ \ x \times cos(angle) + y \times sin(angle)\\
    %          )\)
    %\end{itemize}
    \item{Scalare - punctului \((x, y)\) i se înmulțesc componentele cu doi factori de scalare \(sx\), respectiv \(sy\).}
    %\begin{itemize}
    %    \item \(transform(x, y, scale) = (x \times scale.x, y \times scale.y)\)
    %\end{itemize}
    \item{Înclinare - punctul \((x, y)\) înclinat cu unghiurile \(\alpha_x\) și \(\alpha_y\) se obține prin înmulțirea cu tangentele unghiurilor \cite{affine_transform_skew}
                \[(x', y') = (x + y \times \tan(\alpha_y), y + x \times \tan(\alpha_x))\]}
    %\begin{itemize}
    %    \item \(skew(x, y, angle_x, angle_y) = (\\
    %          \ \ \ x + y \times tan(angle_y),\\
    %          \ \ \ y + x \times tan(angle_x)\\
    %          )\)
    %\end{itemize}
\end{itemize}

În figura \ref{fig-transforms} sunt ilustrate toate transformările afine implementate. De menționat este și faptul că gradienții
acceptă transformări afine, care se vor aplica pe punctele din interiorul dreptunghiului care acoperă figura.

\begin{figure}[ht]
    \includegraphics[height=5cm]{transformari_afine.png}
    \centering
    \caption{Transformările afine implementate, în ordine, de sus în jos}
    \label{fig-transforms}
\end{figure}

\section{Spații de culoare}

Un aspect important când vine vorba de grafică este acela al spațiilor de culoare. Mai precis, spațiile de culoare decid cum
se reproduc culorile (un exemplu popular este spațiul \texttt{sRGB} \cite{sRGB}). În cazul implementării prezentate, toate operațiile
pe culori se petrec în spațiul liniar. Acest lucru permite flexibilitate maximă, deoarece orice fel de corecții asupra
culorilor pot fi implementate de către utilizatorul bibliotecii după ce desenarea figurilor a luat sfârșit.

\chapter{Concluzii}

În această lucrare am prezentat o metodă de a desena eficient, din punct de vedere al memoriei, imagini vectoriale. Am pornit
de la o implementare în care se desenează doar curbe Bézier de gradul 2, dar care este foarte eficientă, pe care am extins-o
ulterior la curbe Bézier de gradul 3 pentru a suporta descrierea figurilor cât mai complexe.

Pentru a fi o bibliotecă de grafică vectorială am adăugat suport și pentru operatori de amestecare, gradienți și transformări
asupra punctelor care constituie figuri vectoriale.

Toate acestea nu necesită decât 2 zone de memorie: o zonă care stochează acoperiri parțiale ale pixelilor, și o zonă care
stochează culorile care vor constitui imaginea finală. Asupra zonei de memorie în care se află acoperirile parțiale se va
efectua o sumă cumulativă pentru a implementa regula de umplere care se bazează pe orientarea primitivelor față de sensul
parcurgerii imaginii (adică de la stânga la dreapta).

\section{Posibile îmbunătățiri}

Cel mai important aspect care s-ar putea îmbunătăți pentru implementare este acela al performanței. În ciuda faptului că implementarea
are deja un grad de eficiență ridicat, potențialul maxim nu a fost atins, deoarece am recurs la diverse simplificări pentru a putea
extinde implentarea la capabilitățile menționate în lucrare. În etapa în care se calculează suma cumulativă există posibilitatea calculării
acesteia în paralel, folosind tehnici precum SIMD \cite{SIMD}. În cazul desenării textului se poate implementa un caz special, care se folosește
de aceste tehnici, deoarece textul nu folosește funcționalități avansate precum gradienți sau operatori de amestecare, fiind astfel posibilă
o implementare simplificată, facilitând îmbunătățirea acesteia.

Un alt aspect care poate fi îmbunătățit este acela al funcționalităților. Curbele eliptice reprezintă un exemplu primitive pentru care nu
am adăugat suport. O metodă de implementare poate fi convertirea acestora la reuniune de curbe Bézier, aceasta fiind o abordare ușor de
implementat, dat fiind faptul că am adăugat deja suport pentru curbe Bézier. De asemenea, gradienții radiali pot beneficia de o îmbunătățire
legată de interfață, și anume faptul că se mai poate specifica un al doilea cerc, care să influențeze traseul gradientului, astfel facilitând
descrierea figurilor care au un grad de complexitate ridicat.

O altă posibilă îmbunătățire poate fi adăugarea suportului pentru animații. Având în vedere că o imagine poate fi desenată rapid, se poate
desena o succesiune de imagini cu diverse transformări aplicate figurilor astfel încât să se observe efectul de animație. O astfel
de abordare ar beneficia animațiile pentru figuri desenate la rezoluții relativ mici, care este probabil cea mai des întâlnită utilizare.
Din păcate, pentru animații la rezoluții mari șansele ca imaginile să fie desenate suficient de rapid pentru a reda efectul de animație scad
semnificativ. O alternativă în acel caz poate fi reprezentată de o metodă de desenare care se folosește de procesorul grafic.

\printbibliography

\end{document}